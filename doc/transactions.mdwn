## Transactions

### Transactions as a Signature Chain

Coins are generated by a so-called COINBASE transaction; this is the only
transaction that is allowed to have zero inputs.  The rules for the COINBASE
output are also strict (people who create COINBASE transactions can't just
write whatever number they want to create).

All other transactions (i.e. the vast majority) must reference the outputs
of an earlier transaction.

The block chain merely provides a container for the transaction chains.
The block chain has very little to do with actual transactions.

The transaction chain is essentially a list of signed messages (barring
the COINBASE).  Let's pretend for now that each transaction has one
input and one output.  The input is a reference to an earlier output,
and the output is a public key.  The clever piece is that only the owner
of the private key companion to a public key output can sign the
transaction input as being valid.  Gulp.  That was a mouthful.

Let's have an example.  A COINBASE transaction creates coins and assigns
them to a particular public key.

    TRANSACTION_01: COINBASE(50 coins)
                 -> PUBLIC_KEY_01

Now; the owner of PUBLIC_KEY_01 (with "owner" defined as the person with
PRIVATE_KEY_01) wants to transfer those coins to PUBLIC_KEY_02.

    TRANSACTION_02: PRIVATE_KEY_01_SIGNATURE(TRANSACTION_01)
                 -> PUBLIC_KEY_02

Only the owner of PRIVATE_KEY_01 can create the signature in
TRANSACTION_02; but anyone who knows PUBLIC_KEY_01 can verify it.
Everyone knows PUBLIC_KEY_01, because it is in TRANSACTION_01.  The
coins created in TRANSACTION_01 have been spent.

The block chain ensures that these two transactions are published and
carved in stone (for all intents).  Everyone on the network has a copy
of the block chain (let's say), and hence the transaction list.

Let's say the owner of PRIVATE_KEY_01 is a cheeky devil and wants to spend that
money again.  He prepares a new transaction, giving the same coins to
PUBLIC_KEY_03 (presumably in exchange for a Ferrari).

    TRANSACTION_03: PRIVATE_KEY_01_SIGNATURE(TRANSACTION_01)
                 -> PUBLIC_KEY_03

He can't reference the output of TRANSACTION_02 because he doesn't own
PRIVATE_KEY_02, and so can't sign that reference, the transaction would
be instantly rejected.  So, he references TRANSACTION_01 again.  His
signature is valid -- his plan has succeeded hasn't it?  No.  The plan
hasn't succeeded.  You see, everyone has an agreed-valid copy of
TRANSACTION_02, which already references the output of TRANSACTION_01.
A quick search through previous transactions will easily reveal that
TRANSACTION_01's output has been spent, in a transaction earlier than
TRANSACTION_03.  That earlier transaction has our cheater's signature on
it, so he cannot claim that it wasn't him that spent it, and
TRANSACTION_03 is rejected.

For an incoming transaction then (i.e. not added to any block yet), we
know a start point -- the transaction references the output of an
earlier transaction.  We start searching at the block that contains that
earlier transaction and look for references to it that are already in
the block chain.  This could easily be a time consuming search if it's
done linearly.  Better then that every block be scanned when it is
received and the transactions pre-assembled so that forward links are
available, as well as backward links.  That is to say, we keep a table
like this:

 - TransactionID
 - ContainingBlockID
 - ParentTransactionID
 - ChildTransactionID

In truth, things are more complicated.  Transactions can have multiple
inputs and multiple outputs.  So we actually need three tables (I've not
listed all fields, only those relevant for creating the transaction
chain):

Transactions:
 - TransactionID
 - ContainingBlockID

TransactionInputs:
 - SplitInputID
 - PartOfTransactionID
 - UsesTransactionID
 - UsesOutputSplitIndex

TransactionOutputs:
 - SplitOutputID
 - PartOfTransactionID
 - OutputIndex
 - Value
 - SpentByTransactionID
 - SpentByInputSplitIndex

The backward references are easily filled in during receipt of a block.
The forward references in `TransactionOutputs` are filled in as the
output blocks appear.

Here's the trick though.  Transaction outputs _are_ transaction inputs.
We don't need three tables at all, two allows us to easily fill in the
chain details as they become available.

Transactions:
 - TransactionID
 - ContainingBlockID
 - LockTime, Version, etc

TransactionOutputs:
 - SplitID
 - CreatedInTransactionID
 - CreationOutputIndex
 - AuthorisationScript
 - Value
 - SpentInTransactionID
 - SpentInputIndex
 - SpentSequenceNumber
 - ClaimantScript

Notice that the splits span two transactions each.  These are the links
in the transaction chain.

    Transaction 1                          Transaction 2
				         \                        /
								  \                      /
									 +- Output -----------+
									 |USING        USED BY|
		               |output 0     input 0|
								   +--------------------+

It's important to recognise that this is not the input/output pairing in
a single transaction, this is a record representing the connection from
one transaction to another.  It is a listing of what happened to the
output from any given transaction.

It is representative of the truth of bitcoin: there is no such thing as
a transaction input, only a reference to a previous transaction output.


### Scripts and Signing

The AuthorisationScript is part of the creation side.  It specifies what
conditions must be met in the future by a claimant in order to spend
the created coins.  The ClaimantScript then supplies those conditions.

The scripts are stack based languages, so the inputs (ClaimantScript)
are "executed" first, followed by the actual authorisation script.

Here's a sample:

    Creation of coins:
    Value: 5000000000
    scriptPubKey: OP_DUP OP_HASH160 404371705fa9bd789a2fcd52d2c580b65d35549d
    OP_EQUALVERIFY OP_CHECKSIG

		Claim of coins:
    Previous tx: f5d8ee39a430901c91a5917b9f2dc19d6d1a0e9cea205b009ca73dd04470b9a6
    Output Index: 0
    scriptSig: 304502206e21798a42fae0e854281abd38bacd1aeed3ee3738d9e1446618c4571d10
    90db022100e2ac980643b0b82c0e88ffdfec6b64e3e6ba35e7ba5fdd7d5d6cc8d25c6b241501

These would be executed in this order:

 - (claimant signature) 304502206e21798a42fae0e854281abd38bacd1aeed3ee3738d9e1446618c4571d10
 - (claimant public key) 90db022100e2ac980643b0b82c0e88ffdfec6b64e3e6ba35e7ba5fdd7d5d6cc8d25c6b241501
 - OP_DUP
 - OP_HASH160
 - (owner address) 404371705fa9bd789a2fcd52d2c580b65d35549d
 - OP_EQUALVERIFY
 - OP_CHECKSIG

The two constants, "signature" and "public key" are executed, and simply
push themselves onto the stack.  Then `OP_DUP` is run.  `OP_DUP`
duplicates the previous item on the stack.

 - (claimant signature + hashtype)
 - (claimant public key)
 - (claimant public key)

Next `OP_HASH160` runs.  Which creates a bitcoin address from a public
key, and pushes that onto the stack.

 - (claimant signature + hashtype)
 - (claimant public key)
 - (claimant address)

The (owner address) is a literal and is simply pushed onto the stack.

 - (claimant signature + hashtype)
 - (claimant public key)
 - (claimant address)
 - (owner address)

`OP_EQUALVERIFY` is two operations combined.  OP_EQUAL followed by
OP_VERIFY.  OP_EQUAL compares the top two stack elements for equality,
replacing them with either 0 or 1 depending on the result.  Let's say
for our example that the claimant is the owner, the top two elements
will be equal and will be replaced with 1:

 - (claimant signature + hashtype)
 - (claimant public key)
 - 1

Next the `OP_VERIFY` part of `OP_EQUALVERIFY` runs.  Checks the top stack
element, removes a 1 (TRUE) and leaves a 0 (FALSE) in place.  If it
finds FALSE it also marks the whole transaction as invalid.  We have a 1
present, so the 1 is simply removed, and the transaction flags left as
they are.

 - (claimant signature + hashtype)
 - (claimant public key)

We're back to the original stack now, but with the script nearly
complete.  The final operation left on the stack is `OP_CHECKSIG`.  The
docs say that

> The entire transaction's outputs, inputs, and script (from the most
> recently-executed OP_CODESEPARATOR to the end) are hashed. The
> signature used by OP_CHECKSIG must be a valid signature for this hash
> and public key. If it is, 1 is returned, 0 otherwise.

I'm not sure this is entirely accurate.  First of all we must ask: which
transaction?  Presumably the one doing the spending, but the script
running is from the creation transaction.  Further, this is only one
input to the transaction, why would the entire thing need signing?
Further, how would one supply a signature of something that contains the
signature?  It's like including a checksum in the data to be
checksummed.  It's impossible that this is the case, so the above
explanation cannot be true.

There is a more detailed description of `OP_CHECKSIG` on the bitcoin
wiki, which is far more plausible.

 - The public key and the signature are popped from the stack, in that
	 order.
 - A new subscript is created from the instruction from the most recent
	 OP_CODESEPARATOR to the end of the script. If there is no
	 OP_CODESEPARATOR the entire script becomes the subscript (hereby
	 referred to as subScript)
 - The sig is deleted from subScript.
 - The hashtype is removed from the last byte of the sig and stored
 - A deep copy is made of the current transaction (hereby referred to
	 txCopy)
 - All OP_CODESEPARATORS are removed from subScript
 - The scripts for all transaction inputs in txCopy are set to empty
	 scripts
 - The script for the current transaction input in txCopy is set to
	 subScript




### Receiving Transactions

Let's think about what happens when a new unchained (as yet) transaction
is broadcast

 - Receive `inv` containing array of MSG_TX type hashes.
 - Create transaction records for these hashes.
 - Request those that we don't know about with `getdata` commands.
 - Receive `tx` message.
 - Hash what we receive and confirm transaction record creation.
 - For each transaction input record, look for the TransactionSplit
   record it references.  This can be found because we have the
   TransactionID and OutputIndex.
 - Once we have that record, we can write the ID of this transaction in
   its InputToTransactionID field.
 - Alternatively, we might notice that there is already an
   InputToTransactionID set.  We would then look at _that_ transaction
   and see whether it's a confirmed transaction (i.e. it's
   ContainingBlockID is set).
 - The rest of the fields fill themselves in.
 - For each output record in the transaction we _create_ a new record in
   the TransactionSplits table.  Note: it is the presence of an output
   that triggers record creation, _not_ the presence of an input record.

