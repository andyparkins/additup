## Transactions

### Transactions as a Signature Chain

Coins are generated by a so-called COINBASE transaction; this is the only
transaction that is allowed to have zero inputs.  The rules for the COINBASE
output are also strict (people who create COINBASE transactions can't just
write whatever number they want to create).

All other transactions (i.e. the vast majority) must reference the outputs
of an earlier transaction.

The block chain merely provides a container for the transaction chains.
The block chain has very little to do with actual transactions.

The transaction chain is essentially a list of signed messages (barring
the COINBASE).  Let's pretend for now that each transaction has one
input and one output.  The input is a reference to an earlier output,
and the output is a public key.  The clever piece is that only the owner
of the private key companion to a public key output can sign the
transaction input as being valid.  Gulp.  That was a mouthful.

Let's have an example.  A COINBASE transaction creates coins and assigns
them to a particular public key.

    TRANSACTION_01: COINBASE(50 coins)
                 -> PUBLIC_KEY_01

Now; the owner of PUBLIC_KEY_01 (with "owner" defined as the person with
PRIVATE_KEY_01) wants to transfer those coins to PUBLIC_KEY_02.

    TRANSACTION_02: PRIVATE_KEY_01_SIGNATURE(TRANSACTION_01)
                 -> PUBLIC_KEY_02

Only the owner of PRIVATE_KEY_01 can create the signature in
TRANSACTION_02; but anyone who knows PUBLIC_KEY_01 can verify it.
Everyone knows PUBLIC_KEY_01, because it is in TRANSACTION_01.  The
coins created in TRANSACTION_01 have been spent.

The block chain ensures that these two transactions are published and
carved in stone (for all intents).  Everyone on the network has a copy
of the block chain (let's say), and hence the transaction list.

Let's say the owner of PRIVATE_KEY_01 is a cheeky devil and wants to spend that
money again.  He prepares a new transaction, giving the same coins to
PUBLIC_KEY_03 (presumably in exchange for a Ferrari).

    TRANSACTION_03: PRIVATE_KEY_01_SIGNATURE(TRANSACTION_01)
                 -> PUBLIC_KEY_03

He can't reference the output of TRANSACTION_02 because he doesn't own
PRIVATE_KEY_02, and so can't sign that reference, the transaction would
be instantly rejected.  So, he references TRANSACTION_01 again.  His
signature is valid -- his plan has succeeded hasn't it?  No.  The plan
hasn't succeeded.  You see, everyone has an agreed-valid copy of
TRANSACTION_02, which already references the output of TRANSACTION_01.
A quick search through previous transactions will easily reveal that
TRANSACTION_01's output has been spent, in a transaction earlier than
TRANSACTION_03.  That earlier transaction has our cheater's signature on
it, so he cannot claim that it wasn't him that spent it, and
TRANSACTION_03 is rejected.

For an incoming transaction then (i.e. not added to any block yet), we
know a start point -- the transaction references the output of an
earlier transaction.  We start searching at the block that contains that
earlier transaction and look for references to it that are already in
the block chain.  This could easily be a time consuming search if it's
done linearly.  Better then that every block be scanned when it is
received and the transactions pre-assembled so that forward links are
available, as well as backward links.  That is to say, we keep a table
like this:

 - TransactionID
 - ContainingBlockID
 - ParentTransactionID
 - ChildTransactionID

In truth, things are more complicated.  Transactions can have multiple
inputs and multiple outputs.  So we actually need three tables (I've not
listed all fields, only those relevant for creating the transaction
chain):

Transactions:
 - TransactionID
 - ContainingBlockID

TransactionInputs:
 - SplitInputID
 - PartOfTransactionID
 - UsesTransactionID
 - UsesOutputSplitIndex

TransactionOutputs:
 - SplitOutputID
 - PartOfTransactionID
 - OutputIndex
 - Value
 - SpentByTransactionID
 - SpentByInputSplitIndex

The backward references are easily filled in during receipt of a block.
The forward references in `TransactionOutputs` are filled in as the
output blocks appear.

Here's the trick though.  Transaction outputs _are_ transaction inputs.
We don't need three tables at all, two allows us to easily fill in the
chain details as they become available.

Transactions:
 - TransactionID
 - ContainingBlockID
 - LockTime, Version, etc

TransactionSplits:
 - SplitInputID
 - OutputFromTransactionID
 - SplitOutputIndex
 - PublicKeyScript
 - Value
 - InputToTransactionID
 - SplitInputIndex
 - InputSequenceNumber
 - SignatureScript

Notice that the splits span two transactions each.  These are the links
in the transaction chain.

### Receiving Transactions

Let's think about what happens when a new unchained (as yet) transaction
is broadcast

 - Receive `inv` containing array of MSG_TX type hashes.
 - Create transaction records for these hashes.
 - Request those that we don't know about with `getdata` commands.
 - Receive `tx` message.
 - Hash what we receive and confirm transaction record creation.
 - For each transaction input record, look for the TransactionSplit
   record it references.  This can be found because we have the
   TransactionID and OutputIndex.
 - Once we have that record, we can write the ID of this transaction in
   its InputToTransactionID field.
 - Alternatively, we might notice that there is already an
   InputToTransactionID set.  We would then look at _that_ transaction
   and see whether it's a confirmed transaction (i.e. it's
   ContainingBlockID is set).
 - The rest of the fields fill themselves in.
 - For each output record in the transaction we _create_ a new record in
   the TransactionSplits table.  Note: it is the presence of an output
   that triggers record creation, _not_ the presence of an input record.

